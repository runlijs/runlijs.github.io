
# 爬楼梯

> https://leetcode-cn.com/problems/climbing-stairs/

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

-----

解题思路，动态规划
- 我们可以用dp[i]来表示我们爬到i级台阶的方案次数.
- 考虑最后一步可能跨一级台阶，也可能跨两级台阶，这表示我们爬到i级台阶的方案数等于dp[i-1]+dp[i-2]的和，所以我们可以列出如下式子
```js
dp[i]=dp[i−1]+dp[i−2]
```
- 边界条件，我们是从第0级开始爬的，所以从第0级爬到第0级我们可以看作只有一种方案，即 dp[0] =1；从第0级到第1级也只有一种方案，即爬一级，dp[1] =1。这两个作为边界条件就可以继续向后推导出第i级的正确结果

- 最后给出爬楼梯代码如下
```js
var climbStairs = function(n) {
  let dp=[1,1]
  for(let i=2;i<=n;i++){
    dp[i] = dp[i-2] + dp[i-1]
  }
  return dp[n]
}
```
- 时间复杂度:O(n)
- 空间复杂度:O(n)

- 但是由于这里的 dp[i] 只和 dp[i-1] 与 dp[-2] 有关，所以我们可以用「滚动数组思想」把空间复杂度优化成 O(1),下面的代码中给出的就是这种实现。

```js
var climbStairs = function(n) {
  let [a,b] = [1,1]
  for(let i=2;i<=n;i++){
    [a,b] = [b,a+b]
  }
  return b
}
```
- 时间复杂度:O(n)
- 空间复杂度:O(1)